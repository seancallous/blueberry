#!/bin/bash

# soap.sh -- the modular dotfiles managemet bash lib

# TODO
# --clean opt that will clean up inactive bars

# get fzf menu if no profile name is given
# hook selection with fzf multiselect
# + dir to midir
# check if sudo is needed by looking for sudo in hooks? but i can't really check all function bodies can I? what if hooks with names containig "sudo" will flag forasksudo
# when no profiles are made, just flag everything as active
# global indent variable?

script_path="$(cd "$(dirname "$0")" >/dev/null 2>&1 ; pwd -P)"

# {{{
black="\e[30m"
red="\e[31m"
green="\e[32m"
yellow="\e[33m"
blue="\e[34m"
magenta="\e[35m"
cyan="\e[36m"
gray="\e[90m"

bold="\e[1m"

escape="\e[0m"
# }}}

_link="$bold▪$escape"
_hook="$boldλ$escape"
_comm="$bold#$escape"

_1="$blue"
_0="$magenta"

_current_color=""
_current_icon=""

# {{{
get_cpos() {
  exec < /dev/tty
  oldstty=$(stty -g)
  stty raw -echo min 0
  echo -en "\033[6n" > /dev/tty
  IFS=';' read -r -d R -a pos
  stty $oldstty
  # change from one-based to zero based so they work with: tput cup $row $col
  row=$((${pos[0]:2} - 1))    # strip off the esc-[
  col=$((${pos[1]} - 1))
  echo $row
}
# }}}

log_bar() {
  echo -e "$_current_color$bold[$escape $bold$1$escape $_current_color$bold]$escape"
}

log() {
  echo -e "$1 $gray$2$escape"
}

get_abspath() { echo "$(realpath -m --no-symlinks ${1/"~"/$HOME})" ; }

# {{{
exe() {
  local cmd arg
  cmd="$1"
  arg="$2"

  # ???
  #[[ "$arg" != "" ]] && $cmd $arg || $cmd

  log "$gray$_current_icon$escape $cmd" ":: $arg"
  out=""
  out_start_col=$(get_cpos)

  $cmd $arg | while read -r l; do
    out+=$'\n'"$l"
    [[ "$?" != "0" ]] && st="1"
    tput cup "$out_start_col" 0 && tput ed
    echo -e "$out" | tail -n+2 | tail -n 5
  done

  tput cup "$((out_start_col-1))" 0
  if [[ "$st" == "0" ]]; then
    log "$_current_color$_current_icon$escape $cmd" ":: $arg"
  else
    log "$red$_current_icon$escape $cmd" ":: $arg"
    echo "$out"
  fi
}
# }}}

# {{{
bar() {
  (( "$#" == 0 )) && return
  name="$1" ; shift
  declare -g $name="$*"
  bars+=("$name")
}
# }}}

# {{{
tub() {
  (( "$#" == 0 )) && return
  name="$1" ; shift
  declare -g $name="$@"
  tubs+=("$name")
}
# }}}

# {{{
#             hooks
# ------------------------------

# force -Syu?
# {{{
pkg() {
  local packages
  local missing_packages

  packages=($@)

  for package in "${packages[@]}"; do
    ! yay -Qi "$package" >/dev/null 2>&1 && missing_packages+=($package)
  done

  if [[ "${#missing_packages[@]}" != "0" ]]; then
    echo -e "  missing packages found $gray${missing_packages[@]}$escape"
    yay -S --noconfirm "${missing_packages[@]}"
  fi

  [[ $? -eq 0 ]] && return 0 || return 1
}
# }}}

# {{{
pypkg() {
  echo "called pypkg()"
}
# }}}

#             bars
# ------------------------------

bar base "
etc/    -> ~/etc
src/    -> ~/src
bin/    -> ~/bin
tmp/    -> ~/tmp
usr/    -> ~/usr
"

bar xorg "
pkg :: xorg-server xorg-xinit xorg-xsetroot xterm xtitle xdo xdotool
"

bar bspwm "
# setting up bspwm
pkg :: bspwm sxhkd rstar
etc/bspwm.d/bspwmrc -> ~/.config/bspwm/bspwmrc
etc/bspwm.d/sxhkdrc -> ~/.config/sxhkd/sxhkdrc
"

bar anywm "
etc/polybar.d/rc    -> ~/.config/polybar/config
etc/picom           -> ~/.config/picom.conf
"

bar pypkgs "
pypkg :: pynvim neovim-remote ueberzug Jinja2 markdown2 Pygments inflect"

bar hosts "
sudo curl :: https://raw.githubusercontent.com/stevenblack/hosts/master/hosts -o /etc/hosts
"

tub default "base bspwm"

# }}}

manage_symlink() {
  local from to a_from a_to
  from="$1"
  to="$2"

  #echo -e "$_link $(basename $from) $gray-> $to$escape"
  log "$gray$_current_icon$escape $(basename $from)" "-> $to"

  #[[ "$to" == "" ]] && log "$_link $from" "broken destination!" ; return 1

  a_from="$script_path/$from"
  a_to="$(get_abspath "$to")"

}

parse() { # $1 - line, $2 - is_active
  local regex_link="(\S*)[[:blank:]]+->[[:blank:]]+(\S*)"
  local regex_hook="(.*)[[:blank:]]+::[[:blank:]]*(.*)"
  local regex_comment="^#\s*(.*)"

  if [[ "$1" =~ $regex_comment ]]; then
    _current_icon="$_comm"
    comment="${BASH_REMATCH[1]}"
    echo -e "$_comm $comment$escape"
  elif [[ "$1" =~ $regex_link ]]; then
    _current_icon="$_link"
    from="${BASH_REMATCH[1]}"
    to="${BASH_REMATCH[2]}"
    manage_symlink "$from" "$to"
  elif [[ "$1" =~ $regex_hook ]]; then
    _current_icon="$_hook"
    cmd="${BASH_REMATCH[1]}"
    arg="${BASH_REMATCH[2]}"
    #log "$_hook $cmd" ":: $arg"
    exe "$cmd" "$arg"
    #[[ "$arg" != "" ]] && $cmd $arg || $cmd
  fi
}

# {{{
welcome() {
  echo -e "
  ____    ___      __     _____     
 /',__\  / __'\  /'__'\  /\ '__'\   
/\__, '\/\ \L\ \/\ \L\.\_\ \ \L\ \  
\/\____/\ \____/\ \__/.\_\  \ ,__/  
 \/___/  \/___/  \/__/\/_/ \ \ \/   
                            \ \_\   
                             \/_/  "
}
# }}}

soap() { # $1 - profile name
  clear
  #welcome
  local profile="$1"

  #log "$magenta$boldλ$escape $profile ${gray}profile$escape"
  #echo -e "$cyan$bold[$escape ${!profile} $cyan$bold]$escape"
  #echo
  # TODO give overview of the profile here, active inactive bars

  for bar in "${bars[@]}"; do
    # active
    if [[ "${!profile}" =~ "$bar" ]]; then
      _current_color="$_1"
      log_bar "$bar"
      #log "$cyan$bold[$escape $bar"

      while read -r l; do
        parse "$l"
      done <<< "${!bar}"

      #echo

    # inactive
    else
      _current_color="$_0"
      log_bar "$bar"
      #echo "disabled"
      #echo
    fi

  done
}

soap default
