#!/usr/bin/env bash

# TODO: it'd be super cool if we were contextually aware, and showed entries that are in the pwd at the top

# disable unicode to speed things up
export LC_ALL=C

# since our delimiter is ascii
d=" "

# load config
DIR="${BASH_SOURCE%/*}"
if [[ ! -d "$DIR" ]]; then DIR="$PWD"; fi
. "$DIR/config.sh"

# load data and create it if it doesn't exist
[ -f "$LANTERN_DATA" ] && data=$(<"$LANTERN_DATA") || touch "$LANTERN_DATA"

init() {
  [[ $# == 0 ]] && opt=c || opt=$1

  case $opt in
    c)
      fzf_margin="--margin=1,2"
      fzf_height="--height=10"
      main
      ;;
    w)
      xdotool search --onlyvisible --classname "lantern" windowunmap \
        || xdotool search --classname "lantern" windowmap \
        || st -n "lantern" -a -g "35x7+0+0" -e "$0" i
      ;;
    i)
      fzf_height="--height=100"
      fzf_margin="--margin=2"
      main
      ;;
    a)
      local e="$(history 2 | head -n 1 | awk '{ print $2 }')"
      local a=$(guess_action "$e")
      add_entry "$a" "$e"
      ;;
    h|help)
      echo "usage"
      ;;
    *)
      return
      #fzf_query="#opt"
      ;;
  esac

  # write to file
  echo "$data" > "$LANTERN_DATA"

  #pkill fzf
}

clean() {
  # now 10 times quicker!
  while IFS="" read -r i a e; do
    if [[ ${e:0:1} == "~" ]]; then
      if [[ ! -e "${e//\~/$HOME}" ]]; then
        e=$(sed 's/[]\/$*.^[]/\\&/g' <<< "$e")
        data=$(sed "/.*${e}$/d" <<< "$data")
      fi
    fi
  done <<< "$data"
}

get_abspath() {
  echo "$(realpath -m --no-symlinks ${1/"~"/$HOME})"
}

ask() {
  tput sc
  echo -e "    y/n? > ${white}\c"
  read -n 1 -r < /dev/tty # lack of redirect breaks the function in a while loop
  echo -e "$escape"
  case "$REPLY" in
    Y|y) true ;;
    N|n) false ;;
    *)
      false
      tput rc && tput ed
      ask "$1"
      ;;
  esac
}

launch() {

  _l() {
    exec setsid -f "$@"
  }

  _x() {
    if [[ "$opt" == "c" ]]; then
      $1
    else
      _l st -e sh -c "$1 ; exec bash" #; pkill fzf #exit 0
    fi
  }

  _d() {
    if [[ "$opt" == "c" ]]; then
      cd "$1"
    else
      _l st -e sh -c "cd $1 ; exec bash" #;  #exit 0
    fi
  }

  _e() {
    if [[ "$opt" == "c" ]]; then
      nvim "$1"
    else
      _l st -e sh -c "nvim $1 ; exec bash"# & wait ; exit 0
    fi
  }

  _f() {
    if [[ "$(file "$1")" == *"PDF"* ]]; then
      _l zathura "$1"
    else
      _e "$1"
    fi
  }

  # FIXME bg closes terminal in console mode
  #_b() {
  #  if [[ "$opt" == "c" ]]; then
  #    _l zathura "$1"
  #  else
  #    _e "$1"
  #  fi
  #}

  entry="${1//\~/$HOME}"

  # black magic
  case "$2" in
    "x") _x "$entry" ;;
    "d") _d "$entry" ;;
    "e") _e "$entry" ;;
    "f") _f "$entry" ;;
    "b") _l sh -c "$entry &" ;;
    "u") _l "$entry" ;;
    "w") _l brave "$entry" ;;
    "r") _l brave "https://old.reddit.com/$entry" ;;
    *)
      echo "|$2|"
      echo "unexpected cmd"
      sleep 1s ;;
  esac
}

# i think it doesn't blink if it's global
select_action() {
  local actions="x execute
d cd directory
e edit
f file
b background
u graphical ui
w browse web
r reddit"

  local a=$(echo "$actions" | fzf $fzf_base --header="  $1")
  if [[ "$a" != "" ]]; then
    a="${a:0:1}"
    action=$a
  else
    exit 0
  fi
}

select_entry() {
  out=$(echo -e "$data" | fzf $fzf_base -d $d --bind=change:top --with-nth=1,2,3 --nth=3 --print-query --expect=tab,ctrl-a,ctrl-d,esc)

  mapfile -t out <<< "$out"
  query="${out[0]}"
  key="${out[1]}"
  selection="${out[2]}"

  index=$(awk -F"$d" '{print $1}' <<< "$selection")
  action=$(awk -F"$d" '{print $2}' <<< "$selection")
  entry=$(awk -F"$d" '{print $3}' <<< "$selection")
}

guess_action() {
  if [[ -d "$1" ]]; then
    action="d"
  elif [[ -x "$1" ]]; then
    action="x"
  elif \
    [[ "$1" == *".com" ]] || [[ "$1" == *".com/"* ]] || \
    [[ "$1" == *".net" ]] || [[ "$1" == *".net/"* ]] || \
    [[ "$1" == *".ru" ]] || [[ "$1" == *".ru/"* ]] || \
    [[ "$1" == *".su" ]] || [[ "$1" == *".su/"* ]] || \
    [[ "$1" == *".cc" ]] || [[ "$1" == *".cc/"* ]]; then
    action="w"
  elif [[ "$1" == "r/"* ]]; then
    action="r"
  else
    action="f"
  fi
}

auto_add_entry() {
  guess_action "$1"
  echo "    $action $1"
  ! ask && select_action "$1"
  add_entry "$action" "$1"
  entry="$1"
}

main() {
  fzf_base="--ansi --reverse --prompt=  \$  --cycle $fzf_height $fzf_margin --info=hidden --no-multi --color=bg:-1,bg+:-1,gutter:-1,hl:15,hl+:15,fg:7,fg+:7,info:7,prompt:7,pointer:4,header:15,preview-fg:8"

  populate

  # only works on second relaunch for some reason
  clean

  return

  select_entry

  case "$key" in
    "tab")
      select_action "$entry"
      # replace action with the new one
      data=$(sed "s+\(^[0-9]*${d}\).\(${d}${entry}$\)+\1${action}\2+g" <<< "$data")
      ;;
    "ctrl-a")
      auto_add_entry "$query"
      ;;
    "esc")
      return
      ;;
  esac

  if [[ "$entry" == "" ]] && [[ "$query" != "" ]]; then
    auto_add_entry "$query"
  fi

  reduce_scores

  # FIXME $d needs to be escaped for sed
  # increment index
  data=$(sed "s+^[0-9]*\(\ ${action}${d}${entry}$\)+$((index+1))\1+g" <<< "$data")

  if [[ "$entry" != "" ]] && [[ "$action" != "" ]]; then
    launch "$entry" "$action"
  fi
}

add_entry() {
  data+="
1${d}${1}${d}${2}"
}

populate() {
  # find all non-hidden folders in home
  # can break if empty (doubt it ever will) without [ -d ${file} ] && 
  #home_dirs=$(for folder in $HOME/*/; do
  #  [ -d $folder ] && echo "$folder"
  #done)
  local home_dirs="$(find $HOME -maxdepth 1 -not -path '*/\.*' -type d | sed '1d')"

  # find everything in them
  local home="$(find $home_dirs \( -name .git \) -prune -o -print)"

  # append all files from home
  home+="
$(find $HOME -maxdepth 1 -type f)"

  # prevent them from sticking together
  [ -s "$LANTERN_DATA" ] && data+="
"

  # add entries to data
  data+=$(while IFS= read -r l; do
    if [ -d "$l" ]; then
      a="d"
    elif [ -x "$l" ]; then
      a="x"
    else
      a="f"
    fi
    echo "1${d}${a}${d}0${d}${l/#$HOME/'~'}"
  done <<< "$home")

  # remove duplicates based on $col in file
  data=$(awk -F"$d" '!x[$4]++' <<< "$data")

  # maybe pipe the output of below into fzf without overwriting a file?
  # but this seems easier though, but stuff can go wrong

  # calculate score and sort, prepare for fzf
  # note the delimiters!
  echo "$data" | awk -v d="$d" -v now="$(date +%s)" -F"$d" '
    function frecency(time) {
      if ( time > 0 ) {
        dt = now-time
        if( dt < 86400 ) return 4
        if( dt < 43200 ) return 8
        if( dt < 3600 ) return 16
      }
      return 1
    }
    {
      score[$4] = $1 / ( length / 2 ) * frecency($3)
      uses[$4] = $1
      action[$4] = $2
      time[$4] = $3
    }
    END {
      for ( x in score ) print score[x] d uses[x] d action[x] d time[x] d x
    }
    ' | sort -k1,1nr | cut -d"" -f2-5

    #if ( $3 in score == 0 ) {
    #  score[$3] = $1 / length
    #  action[$3] = $2
    #}

}

reduce_scores() {
  # we only care about score > 1, so find the first occurrence of index 1
  local line_number=$(awk -v search="^1${d}" '$0~search{print NR-1; exit}' <<< "$data")

  # this should keep things from getting out of control
  (( $line_number < 20 )) && return
  local line=$(head -n 1 <<< "$data")
  local id=$(awk -F"$d" '{print $1}' <<< "$line")
  (( $id < 20 )) &&  return

  # find a random line w/ i > 1
  local rnd=$RANDOM
  let "rnd %= $line_number"
  ((rnd++))
  local j=0
  while read -r line; do
    ((j++))
    [ $j -eq $rnd ] && break
  done <<< "$data"

  # reduce index
  local en=$(awk -F"$d" '{print $3}' <<< "$line")
  local id=$(awk -F"$d" '{print $1}' <<< "$line")
  data=$(sed "s+^[0-9]*\(.*${en}$\)+$((id-1))\1+g" <<< "$data")
}

init $@
