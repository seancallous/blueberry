#!/usr/bin/env bash

# TODO it'd be super cool if we were contextually aware, and showed entries that are in the pwd at the top

_LANTERN_DATA="$HOME/blueberry/lantern.d/data"
_LANTERN_CMD="bb"
_LANTERN_BROWSER="brave"

export LC_ALL=C # disable unicode to speed things up, since our delimiter is ascii
alias ${_LANTERN_CMD:-lantern}="_lantern c"

_lantern() {

  # bail on bad args
  [ $# == 0 ] && return || local _lantern_opt="$1"
  local _lantern_d=" "

  main() { #{{{

    new_entry() { # $1 - entry, $2 - time, $3 - action {{{
      # echo a new entry in a proper format w/ 1 use, speeds up populate
      echo "1$_lantern_d${2}$_lantern_d${3}$_lantern_d${1/#$HOME/'~'}"
    } #}}}

    add_entry() { # $1 - entry, $2 - time, $3 - action {{{
      # append entry generated through the above to data
      [[ $1 == "" ]] || [[ $2 == "" ]] || [[ $3 == "" ]] && return
      data+=$(echo -e "\n$(new_entry $1 $2 $3)")
    } #}}}

    delete_entry() { # $1 - entry {{{
      # remove entry from data
      data=$(awk -v entry="$1" -F"$_lantern_d" '$4 != entry' <<< "$data")
    } #}}}

    update_entry() { # $1 - entry, $2 - index delta, $3 - time, $4 - action {{{
      # update index, timestamp, action of an existing entry
      data=$(awk -v entry="$1" -v dindex="$2" -v time="$3" -v action="$4" -v d="$_lantern_d" -F"$_lantern_d" '
      $4 == entry {
          if ( length(dindex) != 0 ) $1 = $1 + dindex
          if ( length(time) != 0 ) $2 = time
          if ( length(action) == 1 ) $3 = action
      } { print $1 d $2 d $3 d $4 }
      ' <<< "$data")
    } #}}}

    populate() { #{{{
      # find all non-hidden folders in home
      local home_dirs="$(find $HOME -maxdepth 1 -not -path '*/\.*' -type d | tail -n +2)"
      # find everything in them and append entries from home
      local home="$(find $home_dirs \( -name .git \) -prune -o -print)
$(find $HOME -maxdepth 1 -type f)"
      # prevent new and old entries from sticking together
      [ -s "$_LANTERN_DATA" ] && data+="
"
      data+=$(while IFS= read -r l; do
        if [ -d "$l" ]; then
          a="d"
        elif [ -x "$l" ]; then
          a="x"
        else
          a="f"
        fi
        new_entry "$l" 0 "$a"
      done <<< "$home")
      # remove duplicates based on $col in file
      data=$(awk -F"$_lantern_d" '!x[$4]++' <<< "$data")
    } #}}}

    prepare() { #{{{
      # remove non-existent path entries, nb! IFS _lantern_d
      while IFS="" read -r u t a e; do
        if [[ ${e:0:1} == "~" ]] && [[ ! -e "${e//\~/$HOME}" ]]; then
          delete_entry "$e"
        fi
      done <<< "$data"
      # calculate score, sort
      echo "$data" | awk -v d="$_lantern_d" -v now="$(date +%s)" -F"$_lantern_d" '
        function frecency(time) {
          if ( time > 0 ) {
            dt = now-time
            if( dt < 86400 ) return 4
            if( dt < 43200 ) return 8
            if( dt < 3600 ) return 16
          }
          return 1
        }
        length > 0 {
          score[$4] = $1 / ( length / 2 ) * frecency($2)
          uses[$4] = $1
          time[$4] = $2
          action[$4] = $3
          total += $1 - 1
        }
        END {
          if ( total < 100 ) {
            for ( x in score ) print score[x] d uses[x] d time[x] d action[x] d x
          }
          else {
            for ( x in score ) {
              if ( uses[x] > 1 ) { print score[x] d uses[x]-1 d time[x] d action[x] d x }
              else { print score[x] d uses[x] d time[x] d action[x] d x }
            }
          }
        }
      ' | sort -k1,1nr | cut -d"" -f2-5 > "$_LANTERN_DATA"
    } #}}}

    _fzf() { #{{{
      fzf --no-sort --ansi --reverse --prompt="  $ " --info=hidden --no-multi \
        $_lantern_fzf_height $_lantern_fzf_margin \
        --color=bg:-1,bg+:-1,gutter:-1,hl:15,hl+:15,fg:7,fg+:7,info:7,prompt:7,pointer:4,header:15 \
        "$@"
    } #}}}

    select_action() { # $1 - entry {{{
      # show a fzf menu that returns a single letter representing an action
      local actions="x execute
d cd directory
e edit
f file
b background
u graphical ui
w browse web
r reddit"
      local a=$(echo "$actions" | _fzf --sort --bind "esc:abort" --header="  $1")
      [[ "$a" != "" ]] && echo "${a:0:1}"
    } #}}}

    launch() { #{{{

      [[ "$2" == "" ]] && return
      e="${1//\~/$HOME}"

      _l() {
        exec setsid -f "$@"
      }
      _x() {
        [[ "$_lantern_opt" == "c" ]] && $1 || _l st -e bash -c "$1 ; exec $SHELL"
      }
      _d() {
        [[ "$_lantern_opt" == "c" ]] && cd "$1" || _l st -e sh -c "cd $1 ; exec $SHELL"
      }
      _e() {
        [[ "$_lantern_opt" == "c" ]] && nvim "$1" || _l st -e sh -c "$EDITOR $1 ; exec $SHELL"
      }
      _f() {
        if [[ "$(file "$1")" == *"PDF"* ]]; then
          _l zathura "$1"
        else
          _e "$1"
        fi
      }

      # FIXME bg closes terminal in console mode

      case "$2" in
        "x") _x "$e" ;;
        "d") _d "$e" ;;
        "e") _e "$e" ;;
        "f") _f "$e" ;;
        "b") _l sh -c "$e &" ;;
        "u") _l "$e" ;;
        "w") _l "$_LANTERN_BROWSER" "$e" ;;
        "r") _l "$_LANTERN_BROWSER" "$e" "https://old.reddit.com/$e" ;;
        *)
          echo "unexpected cmd: \"$2\""
          sleep 1s ;;
      esac
    } #}}}

    # load data and create it if it doesn't exist
    [ ! -f "$_LANTERN_DATA" ] && touch "$_LANTERN_DATA"

    # fill up the database
    populate

    # get fzf output
    local out=$(echo "$data" | _fzf \
      --print-query \
      --expect "tab,ctrl-a,esc" \
      --bind "ctrl-r:reload(cat $_LANTERN_DATA),change:top" \
      --with-nth=3,4 --nth=2 \
    )

    mapfile -t out <<< "$out" # 0 - query, 1 - key, 2 - selection

    local q="${out[0]}"
    local a="$(awk -F"$_lantern_d" '{ print $3 }' <<< ${out[2]})"
    local e="$(awk -F"$_lantern_d" '{ print $4 }' <<< ${out[2]})"

    local action_override

    case "${out[1]}" in
      "tab")
        action_override="$(select_action $e)"
        update_entry "$e" "" "" "$action_override" ;;
      "esc")
        return ;;
      "ctrl-a")
        if [[ "$q" != "" ]]; then
          local action_add="$(select_action $q)"
          if [[ "$action_add" != "" ]]; then
            add_entry "$q" "$(date +%s)" "$action_add"
            #launch "$q" "$action_add"
          fi
        fi
        ;;
      "") # fzf prints "" on enter
        if [[ "$e" != "" ]] && [[ "$a" != "" ]]; then
          update_entry "$e" 1 "$(date +%s)" ""
          if [[ "$action_override" == "" ]]; then
            launch "$e" "$a"
          else
            launch "$e" "$action_override"
          fi
        fi
        ;;
    esac

    # black magic
    (prepare &) # NOTE: this may cause problems if data is very large and lantern is relaunched quickly, but from testing it so far it only results in a minor data loss (of the latest launch)

  } #}}}

  # initialize
  case "$_lantern_opt" in
    c)
      _lantern_fzf_margin="--margin=1,2"
      _lantern_fzf_height="--height=10"
      main
      ;;
    w)
      xdotool search --onlyvisible --classname "lantern" windowunmap \
      || xdotool search --classname "lantern" windowmap \
      || st -n "lantern" -a -g "35x7+0+0" -e $(realpath ${BASH_SOURCE[0]}) i
      ;;
    i)
      _lantern_fzf_height="--height=100"
      _lantern_fzf_margin="--margin=2"
      main
      ;;
    h|help)
      echo "usage" ;;
    *)
      return ;;
  esac
}

_lantern $@
