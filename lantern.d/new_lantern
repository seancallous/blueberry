#!/usr/bin/env bash

# TODO it'd be super cool if we were contextually aware, and showed entries that are in the pwd at the top
# FIXME wrap everything into one single function to prevent global scope pollution

# ------------------------------------
# prep
# ------------------------------------

# disable unicode to speed things up, since our delimiter is ascii
export LC_ALL=C
d=" "

# load config
DIR="${BASH_SOURCE%/*}"
if [[ ! -d "$DIR" ]]; then DIR="$PWD"; fi
. "$DIR/config.sh"

# load data and create it if it doesn't exist
[ -f "$LANTERN_DATA" ] && data=$(<"$LANTERN_DATA") || touch "$LANTERN_DATA"

# ------------------------------------
# initialization
# ------------------------------------

init() { # $1 - option
  [[ $# == 0 ]] && opt=c || opt=$1
  case $opt in
    c)
      _lantern_fzf_margin="--margin=1,2"
      _lantern_fzf_height="--height=10"
      main ;;
    w)
      xdotool search --onlyvisible --classname "lantern" windowunmap \
        || xdotool search --classname "lantern" windowmap \
        || st -n "lantern" -a -g "35x7+0+0" -e "$0" i ;;
    i)
      _lantern_fzf_height="--height=100"
      _lantern_fzf_margin="--margin=2"
      main ;;
    h|help)
      echo "usage" ;;
    *)
      return ;;
  esac
  echo "$data" > "$LANTERN_DATA"
}

# ------------------------------------
# call center
# ------------------------------------

main() {
  populate

  # run this in the background to speed stuff up
  prepare &
  local out=$(echo "$data" | _fzf \
    --print-query \
    --expect "tab,ctrl-a" \
    --bind "ctrl-r:reload(cat $LANTERN_DATA),change:top" \
    --with-nth=3,4 --nth=2 \
  )

  # get our data back after it was processed
  data=$(<"$LANTERN_DATA")

  # 0 - query, 1 - key, 2 - selection
  mapfile -t out <<< "$out"

  case "${out[1]}" in
    "tab")
      update_entry "${out[2]}" 0 


}

# ------------------------------------
# data manipulation
# ------------------------------------

# echo a new entry in a proper format
# FIXME rename to format_entry or generate_entry
new_entry() { # $1 - entry, $2 - action
  echo "1${d}0${d}${2}${d}${1/#$HOME/'~'}"
}

# remove entry from data
delete_entry() { # $1 - entry
  data=$(awk -v entry="$1" -F"$d" '
    $4 != entry
  ' <<< "$data")
}

# update index, timestamp, action of an existing entry
update_entry() { # $1 - entry, $2 - index delta, $3 - time, $4 - action
  data=$(awk -v entry="$1" -v dindex="$2" -v time="$3" -v action="$4" -F"$d" '
    $4 == entry {
      if ( dindex != 0 ) $1 = $1 + dindex
      if ( length(time) != 0 ) $2 = time
      if ( length(action) == 1 ) $3 = action
    }
  ' <<< "$data")
}

# scan $HOME for entries, append them to data, remove duplicates
populate() {
  # can break if empty (doubt it ever will) without [ -d ${file} ] && 
  #home_dirs=$(for folder in $HOME/*/; do
  #  [ -d $folder ] && echo "$folder"
  #done)

  # find all non-hidden folders in home
  local home_dirs="$(find $HOME -maxdepth 1 -not -path '*/\.*' -type d | sed '1d')"

  # find everything in them
  local home="$(find $home_dirs \( -name .git \) -prune -o -print)"

  # append all files from home
  home+="
$(find $HOME -maxdepth 1 -type f)"

  # prevent new and old entries from sticking together
  [ -s "$LANTERN_DATA" ] && data+="
"

  # add entries to data
  data+=$(while IFS= read -r l; do
    if [ -d "$l" ]; then
      a="d"
    elif [ -x "$l" ]; then
      a="x"
    else
      a="f"
    fi
    new_entry "$l" "$a"
  done <<< "$home")

  # remove duplicates based on $col in file
  data=$(awk -F"$d" '!x[$4]++' <<< "$data")
}

# calculate score, sort, call ctrl-r
prepare() {
  # remove non-existent path entries, nb! IFS
  while IFS="" read -r s t a e; do
    if [[ ${e:0:1} == "~" ]] && [[ ! -e "${e//\~/$HOME}" ]]; then
      delete_entry "$e"
    fi
  done <<< "$data"

  # get ready for fzf
  echo "$data" | awk -v d="$d" -v now="$(date +%s)" -F"$d" '
    function frecency(time) {
      if ( time > 0 ) {
        dt = now-time
        if( dt < 86400 ) return 4
        if( dt < 43200 ) return 8
        if( dt < 3600 ) return 16
      }
      return 1
    }
    length > 0 {
      score[$4] = $1 / ( length / 2 ) * frecency($2)
      uses[$4] = $1
      time[$4] = $2
      action[$4] = $3
    }
    END {
      for ( x in score ) print score[x] d uses[x] d time[x] d action[x] d x
    }
  ' | sort -k1,1nr | cut -d"" -f2-5 > $LANTERN_DATA
  xdotool key ctrl+r
}

# ------------------------------------
# user interaction
# ------------------------------------

# base fzf function
_fzf() {
  fzf --no-sort --ansi --reverse --prompt="  $ " --info=hidden --no-multi \
    $_lantern_fzf_height $_lantern_fzf_margin \
    --color=bg:-1,bg+:-1,gutter:-1,hl:15,hl+:15,fg:7,fg+:7,info:7,prompt:7,pointer:4,header:15 \
    "$@"
}

# show a fzf menu that returns a single letter representing an action
select_action() { # $1 - entry
  local actions="x execute
d cd directory
e edit
f file
b background
u graphical ui
w browse web
r reddit"

  local a=$(echo "$actions" | _fzf --sort --header="  $1")
  [[ "$a" != "" ]] && echo "${a:0:1}"
}

init $@

#select_action "entry"
