"        .
"  __   __)
" (. | /o ______  __  _.
"    |/<_/ / / <_/ (_(__
"    |
"
" cursive lowercase and invita upper

" ------------------------------
"             plug
" ------------------------------

if has('nvim')
  call plug#begin('~/.vim/bundle')

  " general
  Plug 'junegunn/fzf', { 'do': './install --bin' }
  Plug 'junegunn/fzf.vim'

  " coding
  Plug 'Yggdroot/indentline'
  Plug 'neoclide/coc.nvim', {'branch': 'release'}
  Plug 'habamax/vim-godot'
  "Plug 'terryma/vim-multiple-cursors', { 'on': [] }

  " latex
  Plug 'lervag/vimtex'

  " writing
  Plug 'dbmrq/vim-ditto'
  Plug 'ron89/thesaurus_query.vim'
  Plug 'reedes/vim-lexical'
  "Plug 'jooize/vim-colemak'

  " style
  Plug 'morhetz/gruvbox'
  Plug 'sainnhe/sonokai'
  Plug 'ayu-theme/ayu-vim'

  call plug#end()
endif

" ------------------------------
"           settings
" ------------------------------

" rendering
set encoding=utf-8
set nocompatible              " allow vim -u vimrc
set ttyfast                   " fast redraws, not needed in nvim
set synmaxcol=256             " max colums to use highlightig on
"set t_Co=256                 " 256 color support
set termguicolors             " true color support

" wait times
set ttimeout
set ttimeoutlen=30
set timeoutlen=3000

" editor
filetype indent on
set number relativenumber     " relative numbers
set cursorline                " hl current line

set showmatch                 " blink matching brace when a new one is inserted
set matchtime=2               " return quicker

" whitespace
set wrap                      " wrap at the end of a line
set scrolloff=10              " cursor padding in lines
set tabstop=2
set shiftwidth=2
set softtabstop=2
set expandtab
set noshiftround

set formatoptions=tcqrn1

" invisible characters
set listchars=trail:␣
set list

" search
set incsearch                 " search as characters are entered
set hlsearch                  " highlight matches
set ignorecase                " case-insensitive search
set smartcase                 " case-sensitive if search contains uppercase
nnoremap // :noh<return>

set clipboard+=unnamedplus    " global clipboard, don't forget xsel

" code folding
filetype plugin indent on
set foldenable
set foldmethod=marker
syntax enable

" ------------------------------
"           vim magic
" ------------------------------

" hide CursorLine in insert mode
autocmd InsertEnter * set nocul
autocmd InsertLeave * set cul

" disable new line comment
autocmd FileType * setlocal formatoptions-=cro

" custom folding function
" {{{
function! MyFoldText()
  " get the right fold size
  let fold_lines = v:foldend - v:foldstart - 1

  " get window width
  let nucolwidth = &fdc + &number * &numberwidth
  let window_width = winwidth(0) - nucolwidth

  let next_line = getline(v:foldstart + 1)
  let txt = "[+] " . next_line . " "

  let line_count = " +" . fold_lines . "       "

  let txt = txt . repeat(" ", window_width - len(txt) - len(line_count) - 1) . line_count . "     "
  return txt
endfunction
" }}}
set foldtext=MyFoldText()

" format current line as a nice commeht like the one above
" {{{
function! HeaderComment()
  let c = split(&commentstring, '%s')[0]
  call append(line('.')-1, c . " ------------------------------")
  :center 29
  call setline('.', c . " " . getline('.'))
  call append(line('.'), c . " ------------------------------")
endfunction
" }}}
command! HeaderComment call HeaderComment()
map <leader>c :call HeaderComment()

" writing mode
let g:writing_mode_enabled = 0
" {{{
function! WritingMode()
  if g:writing_mode_enabled
    set spell!
    DittoOff
    " autocmd! CWord
    let g:writing_mode_enabled = 0
  else
    call lexical#init({
      \ 'spell': 1,
      \ 'spellang': ['en', 'geographic'],
      \ 'dictionary': ['~/Downloads/cut.txt',
      \                '/usr/share/dict/words',
      \               ],
      \ 'thesaurus': ['~/.vim/thesaurus/mthesaur.txt',
      \              ],
      \ 'spellfile': ['~/.vim/spellcheck/geograpgic.utf-8.add',
      \              ],
      \ })
    DittoOn
    " augroup CWord
    "   autocmd CursorMoved * call SaveCurrentWord()
    " augroup END
    let g:writing_mode_enabled = 1
  endif
endfunction
" }}}
command! WritingMode call WritingMode()

" auto-update current buffer if it's been changed from somewhere else
set autoread
augroup autoRead
  autocmd!
  autocmd CursorHold * silent! checktime
augroup END

" recompile suckless programs automagically
autocmd BufWritePost config.h,config.def.h !sudo make install

" run xrdb whenever Xdefaults or Xresources are updated
autocmd BufWritePost ~/.Xresources,~/.Xdefaults !xrdb %

" pass cword to a bash script an echo the output
" {{{
function! SaveCurrentWord()
  let cword = expand("<cword>")
  let cword_command = 'output-test ' . cword
  let cwordout = system(cword_command)
  echom cwordout
  " maybe grep the thesaurus with inverted keyboard too
  " ideally i'd want to print a list with numbers, and if a type m1 or something it replaces cword with that numbered word
endfunction
" }}}

" ------------------------------
"            keymaps
" ------------------------------

" hardmode
" {{{
noremap <Up> <Nop>
noremap <Down> <Nop>
noremap <Left> <Nop>
noremap <Right> <Nop>
noremap <PageUp> <nop>
noremap <PageDown> <nop>

inoremap <Up> <Nop>
inoremap <Down> <Nop>
inoremap <Left> <Nop>
inoremap <Right> <Nop>
inoremap <PageUp> <nop>
inoremap <PageDown> <nop>
" }}}

" easy split movement
" {{{
nnoremap <c-j> <c-w><c-j>
nnoremap <c-k> <c-w><c-k>
nnoremap <c-l> <c-w><c-l>
nnoremap <c-h> <c-w><c-h>
" }}}

" vi-line movement
nnoremap <expr> j v:count ? 'j' : 'gj'
nnoremap <expr> k v:count ? 'k' : 'gk'

" prevent jumping to the next match when searching with *
nnoremap * *<c-o>

" easy highlighted occurances replacement
nnoremap <c-n> :%s///g<left><left>

" colemak -> qwerty in normal mode
set langmap=fpgjluyrstdneikFPGJLUYRSTDNEIKoO;ertyuiosdfgjklnERTYUIOSDFGJKLNpP
nnoremap <c-s> <c-d>
nnoremap <c-p> <c-r>
nnoremap <c-l> <c-u>

" coc
inoremap <silent><expr> <TAB>
  \ pumvisible() ? "\<C-n>" :
  \ <SID>check_back_space() ? "\<TAB>" :
  \ coc#refresh()
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

" ------------------------------
"       filetype specific
" ------------------------------

" python
au FileType python setlocal tabstop=4 shiftwidth=4 softtabstop=4

" godot
" {{{
func! GDscriptSettings() abort
  let g:godot_executable = '/home/sean/godot/Godot_v3.2.3-stable_x11.64'
  setlocal tabstop=4
  setlocal expandtab
  setlocal shiftwidth=4
  setlocal softtabstop=4

  nnoremap <buffer> <F4> :GodotRunLast<CR>
  nnoremap <buffer> <C-J> :GodotRun<CR>
  nnoremap <buffer> <F6> :GodotRunCurrent<CR>
  nnoremap <buffer> <F7> :GodotRunFZF<CR>

  nnoremap <C-F> :call fzf#run(fzf#wrap({'source': 'find . -name *.gd'}))<cr>
  vnoremap <C-F> :call fzf#run(fzf#wrap({'source': 'find . -name *.gd'}))<cr>
  inoremap <C-F> :call fzf#run(fzf#wrap({'source': 'find . -name *.gd'}))<cr>
endfunc
" }}}
augroup godot | au!
  au FileType gdscript call GDscriptSettings()
augroup end

" ------------------------------
"         plug specific
" ------------------------------

" thesaurus_query
nnoremap zw :ThesaurusQueryReplaceCurrentWord<CR>

" vim-ditto
hi clear SpellBad
hi SpellBad ctermfg=red guifg=#fb4934
execute 'hi SpellCap guifg=#fb4934'
exec 'hi SpellDitto guifg=#fabd2f ctermfg=red'
let g:ditto_hlgroups = ['SpellDitto', ]

" fzf-vim
nnoremap <C-F> :Files<cr>
vnoremap <C-F> <esc>:Files<cr>
inoremap <C-F> <esc>:Files<cr>

" vimtex
let g:tex_flavor  = 'latex'
let g:tex_conceal = ''
"let g:vimtex_fold_manual = 1
let g:vimtex_latexmk_continuous = 1
"let g:vimtex_compiler_progname = 'nvr'
let g:vimtex_view_method = 'zathura'
let g:vimtex_quickfix_latexlog = {'default' : 0}

" indent line
let g:indentLine_char = '│'

" gruvbox
let g:gruvbox_contrast_dark = 'hard'
let g:gruvbox_italicize_comments = '1'
let g:gruvbox_italic = '1'
let g:gruvbox_bold = '0'

" onedark
let g:onedark_color_overrides = {
\ "black": {'gui': '#282c34', 'cterm': '0', 'cterm16': '0' }
\}

try
  " theme : DO NOT REMOVE THIS TAG
colorscheme gruvbox
  catch
  try
    colorscheme termcolors
    catch
  endtry
endtry

" vim-ditto
hi clear SpellBad
hi SpellBad ctermfg=red guifg=#fb4934
hi clear SpellCap
hi SpellCap guifg=#fabd2f
hi clear SpellRare
hi SpellRare guifg=#d3869b
hi SpellDitto guifg=#83a598
let g:ditto_hlgroups = ['SpellDitto']

" ------------------------------
"   sources (keep at the end)
" ------------------------------

source ~/blueberry/etc/vim.d/statusline.vim

